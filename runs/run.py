"""
AI-GENERATED TEST SUITE 
========================================
Test Suite for Calculator Class
Generated by: SWE Multi-Agent Orchestration System  
Request ID: 82dceb2e-603a-4d49-b910-97f797562134
System: sec_agents.swe_orchestrator
Date: November 1, 2025
========================================

GENERATION PROCESS:
AI agents identified test requirements during development:
- Debugger Agent: Proposed test cases for validation
- Reviewer Agent: Recommended comprehensive testing
- Developer Agent: Suggested edge cases and error conditions

TEST COVERAGE GENERATED BY AI:
Basic arithmetic operations (add, subtract, multiply, divide)
Error handling (division by zero, invalid operations)  
Custom operation registration and execution
Edge cases (floating point, large numbers)
Duplicate registration prevention
Input validation and security

Note: These tests were generated by AI based on code analysis.
    Verify test completeness for your specific use case.

Comprehensive tests covering all functionality including edge cases,
error handling, and custom operation registration.
"""

import pytest
import sys
import os

# Add the current directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from calculator import Calculator, power, modulo


class TestCalculator:
    """Test suite for Calculator class."""
    
    def setup_method(self):
        """Set up fresh calculator instance for each test."""
        self.calc = Calculator()
    
    def test_basic_addition(self):
        """Test basic addition operation."""
        assert self.calc.execute_operation('add', 5, 3) == 8
        assert self.calc.execute_operation('add', -2, 7) == 5
        assert self.calc.execute_operation('add', 0, 0) == 0
    
    def test_basic_subtraction(self):
        """Test basic subtraction operation."""
        assert self.calc.execute_operation('subtract', 10, 3) == 7
        assert self.calc.execute_operation('subtract', -5, -2) == -3
        assert self.calc.execute_operation('subtract', 0, 5) == -5
    
    def test_basic_multiplication(self):
        """Test basic multiplication operation."""
        assert self.calc.execute_operation('multiply', 4, 5) == 20
        assert self.calc.execute_operation('multiply', -3, 4) == -12
        assert self.calc.execute_operation('multiply', 0, 100) == 0
    
    def test_basic_division(self):
        """Test basic division operation."""
        assert self.calc.execute_operation('divide', 10, 2) == 5.0
        assert self.calc.execute_operation('divide', 7, 2) == 3.5
        assert self.calc.execute_operation('divide', -8, 4) == -2.0
    
    def test_division_by_zero(self):
        """Test division by zero raises ZeroDivisionError."""
        with pytest.raises(ZeroDivisionError, match="Cannot divide by zero"):
            self.calc.execute_operation('divide', 10, 0)
    
    def test_register_custom_operation(self):
        """Test registering custom operations."""
        self.calc.register_operation('power', power)
        assert self.calc.execute_operation('power', 2, 3) == 8
        assert self.calc.execute_operation('power', 5, 2) == 25
    
    def test_duplicate_operation_registration(self):
        """Test that registering duplicate operations raises ValueError."""
        with pytest.raises(ValueError, match="Operation 'add' already registered"):
            self.calc.register_operation('add', lambda x, y: x + y)
    
    def test_invalid_operation_execution(self):
        """Test executing non-existent operation raises ValueError."""
        with pytest.raises(ValueError, match="Operation 'invalid' not found"):
            self.calc.execute_operation('invalid', 1, 2)
    
    def test_get_available_operations(self):
        """Test getting list of available operations."""
        operations = self.calc.get_available_operations()
        expected = ['add', 'subtract', 'multiply', 'divide']
        assert all(op in operations for op in expected)
        assert len(operations) == 4
    
    def test_modulo_operation(self):
        """Test custom modulo operation."""
        self.calc.register_operation('modulo', modulo)
        assert self.calc.execute_operation('modulo', 10, 3) == 1
        assert self.calc.execute_operation('modulo', 15, 4) == 3
    
    def test_modulo_by_zero(self):
        """Test modulo by zero raises ZeroDivisionError."""
        self.calc.register_operation('modulo', modulo)
        with pytest.raises(ZeroDivisionError, match="Cannot compute modulo with zero"):
            self.calc.execute_operation('modulo', 10, 0)
    
    def test_floating_point_operations(self):
        """Test operations with floating point numbers."""
        assert abs(self.calc.execute_operation('add', 0.1, 0.2) - 0.3) < 1e-10
        assert abs(self.calc.execute_operation('divide', 1, 3) - 0.3333333333333333) < 1e-15
    
    def test_large_numbers(self):
        """Test operations with large numbers."""
        large_num = 10**15
        assert self.calc.execute_operation('add', large_num, 1) == large_num + 1
        assert self.calc.execute_operation('multiply', large_num, 2) == large_num * 2


def test_power_function():
    """Test standalone power function."""
    assert power(2, 3) == 8
    assert power(5, 0) == 1
    assert power(3, 2) == 9


def test_modulo_function():
    """Test standalone modulo function."""
    assert modulo(10, 3) == 1
    assert modulo(15, 4) == 3
    
    with pytest.raises(ZeroDivisionError):
        modulo(10, 0)


if __name__ == "__main__":
    # Run tests if executed directly
    import subprocess
    subprocess.run(["python", "-m", "pytest", __file__, "-v"])